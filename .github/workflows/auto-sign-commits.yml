name: Auto-Sign Commits

# This workflow automatically signs commits from GitHub Actions/bots
# It triggers on pushes to any branch except main

on:
  push:
    branches:
      - '**'
      - '!main'

permissions:
  contents: write

jobs:
  check-and-sign:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Debug workflow context
        run: |
          echo "üîç Workflow triggered by: ${{ github.actor }}"
          echo "üìù Last commit author: $(git log -1 --pretty=format:'%an <%ae>')"
          echo "üìù Last commit committer: $(git log -1 --pretty=format:'%cn <%ce>')"
          echo "üìù Commit SHA: $(git log -1 --pretty=format:'%H')"
          echo "üìù Commit message: $(git log -1 --pretty=format:'%s')"

      - name: Check if commit is from a bot
        id: bot_check
        run: |
          # Get commit author and committer emails
          AUTHOR_EMAIL=$(git log -1 --pretty=format:'%ae')
          COMMITTER_EMAIL=$(git log -1 --pretty=format:'%ce')

          # Define bot email pattern
          # Pattern explanation:
          # - \[bot\]@ matches accounts ending in [bot] like github-actions[bot]
          # - @.*noreply\.github\.com matches GitHub bot email domains
          # - Copilot@ matches Copilot bot accounts like 198982749+Copilot@...
          BOT_EMAIL_PATTERN='(\[bot\]@|@.*noreply\.github\.com|Copilot@)'

          # Check if commit is from a bot (includes Copilot, GitHub Actions, etc.)
          if echo "$AUTHOR_EMAIL" | grep -qE "$BOT_EMAIL_PATTERN"; then
            echo "is_bot=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Detected bot commit from: $AUTHOR_EMAIL"
          elif echo "$COMMITTER_EMAIL" | grep -qE "$BOT_EMAIL_PATTERN"; then
            echo "is_bot=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Detected bot commit from committer: $COMMITTER_EMAIL"
          else
            echo "is_bot=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Not a bot commit (author: $AUTHOR_EMAIL, committer: $COMMITTER_EMAIL)"
          fi

      - name: Check if GPG key is configured
        id: gpg_check
        run: |
          if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "configured=true" >> $GITHUB_OUTPUT
            echo "‚úÖ GPG_PRIVATE_KEY secret is available"
            
            # Check if passphrase is also available
            if [ -n "${{ secrets.GPG_PASSPHRASE }}" ]; then
              echo "‚úÖ GPG_PASSPHRASE secret is also available"
            else
              echo "‚ö†Ô∏è  GPG_PASSPHRASE secret is NOT set (key might not have a passphrase, or this could cause issues)"
            fi
          else
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "‚ùå GPG_PRIVATE_KEY secret is NOT available"
            echo "‚ö†Ô∏è Note: Organization secrets must be explicitly enabled for this repository"
            echo "‚ö†Ô∏è Go to: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Organization secrets"
            echo "‚ö†Ô∏è Or add the secret at the repository level instead"
          fi

      - name: Import GPG key (with passphrase)
        if: |
          steps.bot_check.outputs.is_bot == 'true' &&
          steps.gpg_check.outputs.configured == 'true' &&
          secrets.GPG_PASSPHRASE != ''
        id: import_gpg_with_pass
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_config_global: true
          git_tag_gpgsign: true
          trust_level: 5
        continue-on-error: true

      - name: Import GPG key (without passphrase)
        if: |
          steps.bot_check.outputs.is_bot == 'true' &&
          steps.gpg_check.outputs.configured == 'true' &&
          (secrets.GPG_PASSPHRASE == '' || steps.import_gpg_with_pass.outcome == 'failure')
        id: import_gpg_no_pass
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_config_global: true
          git_tag_gpgsign: true
          trust_level: 5
        continue-on-error: true

      - name: Set GPG import results
        if: |
          steps.bot_check.outputs.is_bot == 'true' &&
          steps.gpg_check.outputs.configured == 'true'
        id: import_gpg
        run: |
          if [ "${{ steps.import_gpg_with_pass.outcome }}" == "success" ]; then
            echo "keyid=${{ steps.import_gpg_with_pass.outputs.keyid }}" >> $GITHUB_OUTPUT
            echo "name=${{ steps.import_gpg_with_pass.outputs.name }}" >> $GITHUB_OUTPUT
            echo "email=${{ steps.import_gpg_with_pass.outputs.email }}" >> $GITHUB_OUTPUT
            echo "fingerprint=${{ steps.import_gpg_with_pass.outputs.fingerprint }}" >> $GITHUB_OUTPUT
            echo "‚úÖ GPG key imported with passphrase"
          elif [ "${{ steps.import_gpg_no_pass.outcome }}" == "success" ]; then
            echo "keyid=${{ steps.import_gpg_no_pass.outputs.keyid }}" >> $GITHUB_OUTPUT
            echo "name=${{ steps.import_gpg_no_pass.outputs.name }}" >> $GITHUB_OUTPUT
            echo "email=${{ steps.import_gpg_no_pass.outputs.email }}" >> $GITHUB_OUTPUT
            echo "fingerprint=${{ steps.import_gpg_no_pass.outputs.fingerprint }}" >> $GITHUB_OUTPUT
            echo "‚úÖ GPG key imported without passphrase"
          else
            echo "::error::Failed to import GPG key with both passphrase variants"
            echo "::error::This usually means the key format is invalid or the passphrase is wrong"
            exit 1
          fi

      - name: Verify GPG import
        if: |
          steps.bot_check.outputs.is_bot == 'true' &&
          steps.gpg_check.outputs.configured == 'true'
        run: |
          set -x  # Enable debug mode

          echo "üîë GPG key import results from action:"
          echo "  Key ID: ${{ steps.import_gpg.outputs.keyid }}"
          echo "  Name: ${{ steps.import_gpg.outputs.name }}"
          echo "  Email: ${{ steps.import_gpg.outputs.email }}"
          echo "  Fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}"
          echo ""

          echo "üìã Listing all GPG secret keys:"
          gpg --list-secret-keys --keyid-format LONG || echo "No secret keys found"
          echo ""

          echo "üîß Git configuration:"
          echo "  user.signingkey = $(git config --get user.signingkey || echo 'NOT SET')"
          echo "  commit.gpgsign = $(git config --get commit.gpgsign || echo 'NOT SET')"
          echo "  user.name = $(git config --get user.name || echo 'NOT SET')"
          echo "  user.email = $(git config --get user.email || echo 'NOT SET')"
          echo ""

          echo "üß™ Testing GPG signing capability:"
          echo "test" | gpg --clear-sign --default-key "${{ steps.import_gpg.outputs.keyid }}" 2>&1 || echo "Failed to test sign"

      - name: Check last commit signature
        id: check_signature
        run: |
          # Check if the last commit is signed
          if git verify-commit HEAD 2>/dev/null; then
            echo "signed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Last commit is already signed"
          else
            echo "signed=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Last commit is not signed"
          fi

      - name: Sign last commit
        if: |
          steps.bot_check.outputs.is_bot == 'true' &&
          steps.gpg_check.outputs.configured == 'true' &&
          steps.check_signature.outputs.signed == 'false'
        run: |
          set -e  # Exit on any error

          # Get the GPG key information
          GPG_KEY_EMAIL="${{ steps.import_gpg.outputs.email }}"
          GPG_KEY_NAME="${{ steps.import_gpg.outputs.name }}"

          # Validate that we have the required information
          if [ -z "$GPG_KEY_EMAIL" ] || [ -z "$GPG_KEY_NAME" ]; then
            echo "::error::Failed to retrieve GPG key information from import step"
            echo "::error::Email: ${GPG_KEY_EMAIL:-<empty>}"
            echo "::error::Name: ${GPG_KEY_NAME:-<empty>}"
            exit 1
          fi

          echo "üîß Configuring Git to use GPG key identity:"
          echo "  Name: $GPG_KEY_NAME"
          echo "  Email: $GPG_KEY_EMAIL"

          # Configure Git to use the GPG key's identity for this commit
          git config user.name "$GPG_KEY_NAME"
          git config user.email "$GPG_KEY_EMAIL"

          # Amend the last commit with a signature and update author to match GPG key
          # This changes both the author and committer to match the GPG key
          if ! git commit --amend --no-edit --reset-author -S; then
            echo "::error::Failed to sign commit"
            echo "::error::This usually means:"
            echo "::error::  1. GPG key cannot be found or accessed"
            echo "::error::  2. Passphrase is incorrect (if key is protected)"
            echo "::error::  3. Git configuration issue"
            echo "::error::Check the 'Verify GPG import' step output above for details"
            exit 1
          fi

          echo "‚úÖ Signed commit: $(git log -1 --pretty=format:'%h - %s')"
          echo "‚úÖ Author set to: $(git log -1 --pretty=format:'%an <%ae>')"

      - name: Push signed commit
        if: |
          steps.bot_check.outputs.is_bot == 'true' &&
          steps.gpg_check.outputs.configured == 'true' &&
          steps.check_signature.outputs.signed == 'false'
        run: |
          git push --force-with-lease
          echo "‚úÖ Pushed signed commit to ${{ github.ref }}"

      - name: Warning if no GPG key
        if: |
          steps.bot_check.outputs.is_bot == 'true' &&
          steps.gpg_check.outputs.configured == 'false' &&
          steps.check_signature.outputs.signed == 'false'
        run: |
          echo "::error::‚ùå GPG_PRIVATE_KEY secret is not accessible to this workflow"
          echo "::error::üìç Current configuration:"
          echo "::error::   - Secret exists at: Organization level"
          echo "::error::   - Workflow trying to access: Repository secrets"
          echo "::error::"
          echo "::error::üîß Solution 1: Enable organization secret for this repository"
          echo "::error::   1. Go to: https://github.com/organizations/FreeForCharity/settings/secrets/actions"
          echo "::error::   2. Find GPG_PRIVATE_KEY in organization secrets"
          echo "::error::   3. Click 'Update' and ensure this repository is selected"
          echo "::error::"
          echo "::error::üîß Solution 2: Copy secret to repository level"
          echo "::error::   1. Go to: https://github.com/FreeForCharity/ffcadmin.org/settings/secrets/actions"
          echo "::error::   2. Click 'New repository secret'"
          echo "::error::   3. Name: GPG_PRIVATE_KEY"
          echo "::error::   4. Paste the private key value"
          echo "::error::"
          echo "::error::üìñ See GPG_SIGNING.md and QUICK_START.md for detailed instructions."
